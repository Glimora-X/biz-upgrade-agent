# 修复说明 - 冲突等待

## 🐛 问题

当执行 `git pull` 或 `git merge` 出现冲突时，流程没有等待用户解决冲突，而是直接继续执行下一步（升级脚本命令），导致在冲突未解决的情况下执行后续操作。

## 🔍 问题原因

### 原代码逻辑

```typescript
private async runWithConflictSupport(command: string, cwd: string) {
  this.output.appendLine(`> ${command}`);
  try {
    const { stdout, stderr } = await execAsync(command, { cwd });
    // ... 命令执行成功 ...
  } catch (error) {
    // 检测到冲突或合并失败
    if (isConflict || isMergeOrPull) {
      this.output.appendLine('⚠️  检测到合并冲突或中断，请手动解决');
      
      // 显示警告消息（非阻塞）
      vscode.window.showWarningMessage(...);
      
      // 打开 SCM 视图
      await this.openConflictResolver();
      
      // ❌ 问题：直接 return，没有等待用户解决冲突
      return;
    }
  }
}
```

**问题**：
1. 检测到冲突后，只是打开了 SCM 视图
2. 显示了一个非模态的警告消息（可以被忽略）
3. 然后直接 `return`，方法结束
4. 流程继续执行下一步（升级脚本）❌
5. 用户还没来得及解决冲突，后续命令就开始执行了

## ✅ 解决方案

### 调用 `handleConflict` 方法等待用户操作

修改 `runWithConflictSupport` 方法，在检测到冲突后调用 `handleConflict` 方法，该方法会：
1. 列出所有冲突文件
2. 打开 SCM 视图
3. 显示**模态对话框**，等待用户选择
4. 用户解决冲突后点击"继续"才继续流程

### 修复后的代码

```typescript
private async runWithConflictSupport(command: string, cwd: string) {
  this.output.appendLine(`> ${command}`);
  try {
    const { stdout, stderr } = await execAsync(command, { cwd });
    if (stdout) this.output.appendLine(stdout.trim());
    if (stderr) this.output.appendLine(stderr.trim());
  } catch (error) {
    const err = error as { stderr?: string; stdout?: string; message: string };
    const stderr = (err.stderr || '').trim();
    const stdout = (err.stdout || '').trim();
    const message = err.message || '';
    const merged = [stdout, stderr, message].filter(Boolean).join('\n');

    const isConflict = /CONFLICT|Automatic merge failed/i.test(merged);
    const isMergeOrPull = /git (pull|merge)/i.test(command);

    // 检测到冲突或合并失败
    if (isConflict || isMergeOrPull) {
      if (merged) this.output.appendLine(merged);
      
      // ✅ 检查是否真的有冲突文件
      const hasConflicts = await this.checkConflictFiles(cwd);
      
      if (hasConflicts) {
        // ✅ 有冲突，调用 handleConflict 等待用户解决
        await this.handleConflict(cwd);
      } else {
        // 可能是其他合并问题，输出警告但继续
        this.output.appendLine('');
        this.output.appendLine('⚠️  合并命令执行失败，但未检测到冲突文件');
        this.output.appendLine('');
      }
      return;
    }

    // 其他错误
    throw new Error(err.message);
  }
}
```

## 📊 修复对比

### 修复前

```
执行 git pull origin plus-test-250918
  ↓
检测到冲突 ⚠️
  ↓
打开 SCM 视图
  ↓
显示非模态警告消息
  ↓
方法返回 ❌
  ↓
继续执行下一步：执行升级脚本 ❌
  ↓
用户还没解决冲突！❌
```

### 修复后

```
执行 git pull origin plus-test-250918
  ↓
检测到冲突 ⚠️
  ↓
检查冲突文件 ✅
  ↓
调用 handleConflict() ✅
  ↓
列出冲突文件
  ↓
打开 SCM 视图
  ↓
显示模态对话框 ✅
╭────────────────────────────────────╮
│ ⚠️  解决冲突                       │
│                                    │
│ 存在 3 个冲突文件，请在 SCM 视图   │
│ 中解决后点击"继续"                 │
│                                    │
│ 冲突文件：                         │
│ - src/utils.ts                     │
│ - src/config.ts                    │
│ - package.json                     │
│                                    │
│  [重新检查] [强制继续] [中止]      │
╰────────────────────────────────────╯
  ↓
等待用户解决冲突... ⏸️
  ↓
用户解决冲突并点击"继续" ✅
  ↓
重新检查冲突文件
  ↓
没有冲突文件 ✅
  ↓
继续执行下一步：执行升级脚本 ✅
```

## 🎨 用户体验

### 场景：合并时出现冲突

```
1. 执行 git pull origin plus-test-250918
   ↓
2. 检测到冲突
   ↓
3. 输出频道显示：
   ⚠️  检测到合并冲突，需要手动解决
   
   冲突文件列表：
     - src/utils.ts
     - src/config.ts
     - package.json
   ↓
4. 自动打开 SCM 视图（源代码管理）
   ↓
5. 弹出模态对话框（阻塞流程）
   ╭────────────────────────────────────╮
   │ ⚠️  解决冲突                       │
   │                                    │
   │ 存在 3 个冲突文件，请在 SCM 视图   │
   │ 中解决后点击"继续"                 │
   │                                    │
   │  [重新检查] [强制继续] [中止]      │
   ╰────────────────────────────────────╯
   ↓
6. 用户在 SCM 视图中解决冲突
   - 点击冲突文件
   - 选择保留哪些代码
   - 标记为已解决
   ↓
7. 点击"重新检查"
   ↓
8. 系统检查冲突文件
   - 如果还有冲突，重复步骤 5-7
   - 如果没有冲突，继续流程
   ↓
9. 输出：✅ 冲突已解决
   ↓
10. 继续执行下一步（升级脚本）
```

## 🔧 `handleConflict` 方法详解

### 方法功能

```typescript
private async handleConflict(cwd: string) {
  // 1. 输出警告信息
  this.output.appendLine('⚠️  检测到合并冲突，需要手动解决');

  // 2. 列出冲突文件
  const { stdout } = await execAsync('git diff --name-only --diff-filter=U', { cwd });
  const conflictFiles = stdout.trim().split('\n').filter(Boolean);
  this.output.appendLine('\n冲突文件列表：');
  conflictFiles.forEach(file => {
    this.output.appendLine(`  - ${file}`);
  });

  // 3. 打开 SCM 视图
  await this.openConflictResolver();

  // 4. 暂停流程，显示模态对话框，等待用户选择
  await this.waitForContinue({
    kind: 'pause',
    title: '⚠️  解决冲突',
    detail: `存在 ${conflictFiles.length} 个冲突文件，请在 SCM 视图中解决后点击"继续"

冲突文件：
${conflictFiles.map(f => `  - ${f}`).join('\n')}

操作步骤：
1. 在左侧"源代码管理"视图中查看冲突文件
2. 点击冲突文件，解决冲突（接受传入、接受当前、或手动编辑）
3. 标记所有冲突为已解决
4. 点击下方"继续"按钮

提示：
- 可以点击"重新检查"再次检测冲突
- 如果确认已解决，可点击"强制继续"
- 如果不想继续，可点击"中止"`,
  });

  // 5. 用户点击"继续"后，重新检查冲突文件
  const stillHasConflicts = await this.checkConflictFiles(cwd);

  if (stillHasConflicts) {
    // 6. 如果还有冲突，提示用户
    const choice = await vscode.window.showWarningMessage(
      '仍然存在未解决的冲突，请继续解决',
      { modal: true },
      '重新检查',
      '强制继续',
      '中止'
    );

    if (choice === '重新检查') {
      // 递归调用，重新检查
      await this.handleConflict(cwd);
    } else if (choice === '中止') {
      throw new Error('用户中止：存在未解决的冲突');
    }
    // "强制继续" 会直接继续执行
  } else {
    // 7. 没有冲突了，输出成功消息
    this.output.appendLine('✅ 冲突已解决\n');
  }
}
```

### 用户选项

| 选项 | 行为 |
|------|------|
| **继续** | 重新检查冲突文件，如果没有冲突则继续流程 |
| **重新检查** | 再次检查冲突文件，显示当前冲突状态 |
| **强制继续** | 不管是否有冲突，强制继续流程（不推荐） |
| **中止** | 终止整个升级流程 |

## 🔍 冲突检测机制

### `checkConflictFiles` 方法

```typescript
private async checkConflictFiles(cwd: string): Promise<boolean> {
  try {
    // 使用 git diff 查找冲突文件（状态为 U = Unmerged）
    const { stdout } = await execAsync('git diff --name-only --diff-filter=U', { cwd });
    const conflictFiles = stdout.trim();
    return conflictFiles.length > 0;
  } catch {
    return false;
  }
}
```

**工作原理**：
- `git diff --name-only --diff-filter=U`：列出所有未合并（Unmerged）的文件
- 如果有输出，说明有冲突文件
- 如果没有输出，说明所有冲突都已解决

### 冲突检测流程

```
1. 执行 git pull/merge
   ↓
2. 命令失败，捕获错误
   ↓
3. 检查错误信息是否包含 "CONFLICT" 或 "Automatic merge failed"
   ↓
4. 调用 checkConflictFiles() 检查实际的冲突文件
   ↓
5. 如果有冲突文件：
   - 调用 handleConflict() 等待用户解决
   如果没有冲突文件：
   - 可能是其他问题，输出警告但继续
```

## 📝 Git 冲突标记

### 冲突文件内容示例

```javascript
// src/utils.ts
export function helper() {
<<<<<<< HEAD
  // 当前分支的代码
  return 'current';
=======
  // 合并进来的代码
  return 'incoming';
>>>>>>> plus-test-250918
}
```

### VS Code SCM 视图

在源代码管理视图中，冲突文件会显示为：
```
📁 合并更改 (3)
  ⚠️ src/utils.ts      [C]  ← C 表示 Conflict
  ⚠️ src/config.ts     [C]
  ⚠️ package.json      [C]
```

点击冲突文件后，可以：
- **接受当前更改**：保留当前分支的代码
- **接受传入更改**：保留合并进来的代码
- **接受双方更改**：保留两边的代码
- **手动编辑**：自己决定保留什么

## ✅ 修复清单

- [x] ✅ 修改 `runWithConflictSupport` 方法
- [x] ✅ 检测到冲突时调用 `handleConflict`
- [x] ✅ 使用 `checkConflictFiles` 检查实际的冲突文件
- [x] ✅ 等待用户解决冲突后再继续
- [x] ✅ 显示模态对话框（阻塞流程）
- [x] ✅ 支持"重新检查"选项
- [x] ✅ 支持"强制继续"选项
- [x] ✅ 支持"中止"选项
- [x] ✅ 编译通过
- [x] ✅ 修复说明文档

## 🧪 测试验证

### 测试步骤

1. **重新加载窗口**
   ```
   Cmd+Shift+P → Reload Window
   ```

2. **运行快速升级**
   ```
   Cmd+Shift+P → Biz Migration: 快速升级（Test/Inte 环境）
   ```

3. **模拟冲突场景**
   - 在本地修改一些文件（例如 `src/utils.ts`）
   - 不提交，直接运行升级
   - 当执行 `git pull origin plus-test-250918` 时会出现冲突

4. **观察冲突处理**
   - ✅ 检测到冲突
   - ✅ 列出冲突文件
   - ✅ 自动打开 SCM 视图
   - ✅ 显示模态对话框
   - ✅ 流程暂停，等待用户操作

5. **解决冲突**
   - 在 SCM 视图中点击冲突文件
   - 选择保留哪些代码
   - 标记为已解决
   - 点击"继续"

6. **验证继续执行**
   - ✅ 重新检查冲突文件
   - ✅ 没有冲突了
   - ✅ 输出"✅ 冲突已解决"
   - ✅ 继续执行升级脚本

### 预期结果

```
✅ 检测到冲突时会暂停流程
✅ 显示模态对话框，阻塞后续操作
✅ 列出所有冲突文件
✅ 自动打开 SCM 视图
✅ 等待用户解决冲突
✅ 用户点击"继续"后重新检查
✅ 如果还有冲突，继续等待
✅ 如果没有冲突，继续流程
✅ 不会在冲突未解决时执行升级脚本
```

## 💡 使用建议

### 如何解决 Git 冲突

1. **查看冲突文件**
   - 在 SCM 视图中，冲突文件会标记为 `[C]`
   - 点击文件查看冲突内容

2. **解决冲突**
   - **接受当前更改**：保留本地的代码
   - **接受传入更改**：保留远程的代码
   - **接受双方更改**：两边都保留（需要手动调整）
   - **手动编辑**：删除冲突标记，自己决定保留什么

3. **标记为已解决**
   - 解决冲突后，文件会从"合并更改"移到"暂存的更改"
   - 所有冲突文件都解决后，点击"继续"

4. **如果不确定**
   - 点击"重新检查"查看当前状态
   - 可以随时点击"中止"终止流程

### 强制继续的风险

**不推荐**使用"强制继续"，除非：
- 你确定冲突不影响后续操作
- 你知道如何手动解决剩余的冲突
- 你了解强制继续的后果

**强制继续的风险**：
- ❌ 代码可能包含冲突标记（`<<<<<<< HEAD`）
- ❌ 编译可能失败
- ❌ 功能可能异常
- ❌ 需要手动修复

## 🎉 完成

现在：
- ✅ 检测到冲突时会真正等待用户解决
- ✅ 显示模态对话框，阻塞流程
- ✅ 列出所有冲突文件
- ✅ 支持重新检查冲突状态
- ✅ 不会在冲突未解决时执行后续命令
- ✅ 用户体验更好，更安全

**请重新加载窗口并测试！** 🚀

---

*修复时间: 2024-12-19*
*问题: 冲突时没有等待用户解决就继续执行*
*解决: 调用 handleConflict 方法等待用户操作*

